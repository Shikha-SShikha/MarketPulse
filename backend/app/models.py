"""SQLAlchemy ORM models for the STM Intelligence Brief System."""

import uuid
from datetime import datetime, date
from typing import List, Optional

from sqlalchemy import (
    Column, String, Text, DateTime, Date, Integer, Boolean,
    Enum as SQLEnum, Index, ForeignKey, JSON, Float
)
from sqlalchemy.dialects.postgresql import UUID, ARRAY
from sqlalchemy.orm import relationship
from pgvector.sqlalchemy import Vector

from app.database import Base


# Enum values as strings for flexibility
class EventType:
    """Event types for signals."""
    ANNOUNCEMENT = "announcement"
    HIRE = "hire"
    POLICY = "policy"
    PARTNERSHIP = "partnership"
    MA = "m&a"
    RETRACTION = "retraction"
    LAUNCH = "launch"
    OTHER = "other"


class Confidence:
    """Confidence levels for signals."""
    LOW = "Low"
    MEDIUM = "Medium"
    HIGH = "High"


class ImpactArea:
    """Impact areas for signals and themes."""
    OPS = "Ops"
    TECH = "Tech"
    INTEGRITY = "Integrity"
    PROCUREMENT = "Procurement"


class SignalStatus:
    """Status values for signal review workflow."""
    PENDING_REVIEW = "pending_review"
    APPROVED = "approved"
    REJECTED = "rejected"


class SourceType:
    """Data source types for automated collection."""
    RSS = "rss"
    LINKEDIN = "linkedin"
    WEB = "web"
    EMAIL = "email"


class EntitySegment:
    """Entity segment types for market intelligence."""
    CUSTOMER = "customer"
    COMPETITOR = "competitor"
    INDUSTRY = "industry"
    INFLUENCER = "influencer"


class Signal(Base):
    """
    A single piece of market/competitive intelligence with provenance.

    Signals are collected by curators from public sources and stored
    with full provenance (source URL, timestamp, confidence level).
    """
    __tablename__ = "signals"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Core signal data
    entity = Column(String(255), nullable=False, index=True)
    event_type = Column(String(50), nullable=False)
    topic = Column(String(255), nullable=False, index=True)

    # Evidence and provenance
    source_url = Column(Text, nullable=False)
    evidence_snippet = Column(Text, nullable=False)
    confidence = Column(String(10), nullable=False)  # Low, Medium, High

    # Classification
    impact_areas = Column(ARRAY(String), nullable=False)
    entity_tags = Column(ARRAY(String), nullable=True, default=[])

    # Metadata
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
    curator_name = Column(String(255), nullable=True)  # NULL for automated signals
    notes = Column(Text, nullable=True)

    # Automation fields
    status = Column(String(20), nullable=False, default="approved")  # pending_review, approved, rejected
    data_source_id = Column(UUID(as_uuid=True), ForeignKey("data_sources.id"), nullable=True)
    reviewed_at = Column(DateTime, nullable=True)
    reviewed_by = Column(String(255), nullable=True)

    # RAG/Semantic search
    embedding = Column(Vector(1536), nullable=True)  # OpenAI text-embedding-3-small (1536 dimensions)

    # Soft delete
    deleted_at = Column(DateTime, nullable=True)

    # Relationships (many-to-many with entities via junction table)
    entity_links = relationship("SignalEntity", back_populates="signal", cascade="all, delete-orphan")

    # Indexes for common queries
    __table_args__ = (
        Index('ix_signals_entity_created', 'entity', 'created_at'),
        Index('ix_signals_topic_created', 'topic', 'created_at'),
        Index('ix_signals_status', 'status', 'deleted_at'),
    )

    def __repr__(self):
        return f"<Signal {self.id}: {self.entity} - {self.topic}>"


class Theme(Base):
    """
    A cluster of related signals grouped by topic and entity proximity.

    Themes are automatically generated by the weekly synthesis job.
    Each theme includes "So What" (why it matters) and "Now What" (actions).
    """
    __tablename__ = "themes"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Theme content
    title = Column(String(500), nullable=False)
    signal_ids = Column(ARRAY(UUID(as_uuid=True)), nullable=False)
    key_players = Column(ARRAY(String), nullable=True, default=[])

    # Analysis
    aggregate_confidence = Column(String(10), nullable=False)  # Low, Medium, High
    impact_areas = Column(ARRAY(String), nullable=False)

    # Actionable insights
    so_what = Column(Text, nullable=False)  # Why this matters to STM suppliers
    now_what = Column(ARRAY(Text), nullable=False)  # Action bullets for sales

    # Metadata
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)

    def __repr__(self):
        return f"<Theme {self.id}: {self.title}>"


class WeeklyBrief(Base):
    """
    A ranked collection of themes for a specific week.

    Generated automatically by the weekly synthesis job (Sunday 5 PM UTC).
    Contains all themes for the week, ranked by impact.
    """
    __tablename__ = "weekly_briefs"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Week boundaries
    week_start = Column(Date, nullable=False, index=True)
    week_end = Column(Date, nullable=False)

    # Brief content
    theme_ids = Column(ARRAY(UUID(as_uuid=True)), nullable=False)  # Ordered by rank

    # Metadata
    generated_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
    total_signals = Column(Integer, nullable=False, default=0)
    coverage_areas = Column(ARRAY(String), nullable=True, default=[])

    # Indexes for common queries
    __table_args__ = (
        Index('ix_weekly_briefs_week', 'week_start', 'week_end'),
    )

    def __repr__(self):
        return f"<WeeklyBrief {self.id}: {self.week_start} to {self.week_end}>"


class DataSource(Base):
    """
    Configuration for automated data collection sources.

    Tracks RSS feeds, web scrapers, LinkedIn sources, and email ingestion
    with collection metadata and error tracking.
    """
    __tablename__ = "data_sources"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Source configuration
    name = Column(String(255), nullable=False)  # e.g., "Springer Blog RSS"
    source_type = Column(String(50), nullable=False)  # rss, linkedin, web, email
    url = Column(Text, nullable=True)  # Feed URL or website URL
    config = Column(JSON, nullable=True)  # Source-specific config (selectors, keywords)

    # Collection metadata
    enabled = Column(Boolean, nullable=False, default=True, index=True)
    last_fetched_at = Column(DateTime, nullable=True)
    last_success_at = Column(DateTime, nullable=True)
    error_count = Column(Integer, nullable=False, default=0)
    last_error = Column(Text, nullable=True)

    # Defaults for signals from this source
    default_confidence = Column(String(10), nullable=False, default="Medium")  # Low, Medium, High
    default_impact_areas = Column(ARRAY(String), nullable=True, default=[])

    # Metadata
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self):
        return f"<DataSource {self.id}: {self.name} ({self.source_type})>"


class Notification(Base):
    """
    Dashboard notifications for curators.

    Alerts about pending signals, trigger events, and system messages.
    """
    __tablename__ = "notifications"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Notification content
    type = Column(String(50), nullable=False)  # pending_signals, trigger_alert, system
    title = Column(String(500), nullable=False)
    message = Column(Text, nullable=False)
    link = Column(Text, nullable=True)  # Link to review page, signal, etc.

    # Notification state
    read = Column(Boolean, nullable=False, default=False)
    dismissed = Column(Boolean, nullable=False, default=False)

    # Metadata
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)

    # Indexes for common queries
    __table_args__ = (
        Index('ix_notifications_unread', 'read', 'dismissed', 'created_at'),
    )

    def __repr__(self):
        return f"<Notification {self.id}: {self.type} - {self.title}>"


class Entity(Base):
    """
    Entity metadata with segment classification.

    Entities represent companies, organizations, journals, or influencers
    mentioned in signals. Segmentation enables targeted filtering and analytics.
    """
    __tablename__ = "entities"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False, unique=True, index=True)
    segment = Column(String(50), nullable=False, index=True)  # customer, competitor, industry, influencer
    aliases = Column(ARRAY(String), nullable=True, default=[])
    entity_metadata = Column(JSON, nullable=True)  # Extensible: {website, hq, sales_rep, account_tier, etc.}
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)
    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationship to signals (via junction table)
    signal_links = relationship("SignalEntity", back_populates="entity", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Entity {self.name} ({self.segment})>"


class SignalEntity(Base):
    """
    Junction table for many-to-many Signal-Entity relationship.

    Allows signals to be associated with multiple entities (e.g., "Elsevier partners with Springer")
    and enables segment-based filtering and analytics.
    """
    __tablename__ = "signal_entities"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    signal_id = Column(UUID(as_uuid=True), ForeignKey("signals.id", ondelete="CASCADE"), nullable=False, index=True)
    entity_id = Column(UUID(as_uuid=True), ForeignKey("entities.id", ondelete="CASCADE"), nullable=False, index=True)
    is_primary = Column(Boolean, nullable=False, default=False)  # Primary entity for the signal
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)

    # Relationships
    signal = relationship("Signal", back_populates="entity_links")
    entity = relationship("Entity", back_populates="signal_links")

    def __repr__(self):
        return f"<SignalEntity signal={self.signal_id} entity={self.entity_id} primary={self.is_primary}>"


class EvaluationRun(Base):
    """
    Evaluation run for AI-generated content quality assessment.

    Tracks quality metrics for weekly briefs, themes, and signal summaries
    to ensure accuracy, grounding, and actionability. Supports continuous
    improvement by monitoring evaluation scores over time.
    """
    __tablename__ = "evaluation_runs"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Content being evaluated
    content_type = Column(String(50), nullable=False, index=True)  # weekly_brief, theme, signal_summary
    content_id = Column(UUID(as_uuid=True), nullable=False, index=True)  # ID of the content

    # Quality scores (0-10 scale, 10 = perfect)
    hallucination_score = Column(Float, nullable=False)  # 10 = no hallucinations
    grounding_score = Column(Float, nullable=False)  # 10 = perfectly grounded in evidence
    relevance_score = Column(Float, nullable=False)  # 10 = highly relevant insights
    actionability_score = Column(Float, nullable=False)  # 10 = clear actionable advice
    coherence_score = Column(Float, nullable=False)  # 10 = logically coherent

    # Overall assessment
    overall_score = Column(Float, nullable=False)  # Average of all scores
    passed = Column(Boolean, nullable=False)  # True if overall_score >= threshold
    threshold = Column(Float, nullable=False, default=9.5)  # Quality threshold (95%)

    # Evaluation metadata
    evaluator_model = Column(String(100), nullable=True)  # LLM used for scoring (e.g., "gpt-4o-mini")
    evaluation_method = Column(String(50), nullable=False)  # "rule_based", "llm_judge", "hybrid"
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)

    # Relationships
    issues = relationship("EvaluationIssue", back_populates="evaluation_run", cascade="all, delete-orphan")

    # Indexes for monitoring queries
    __table_args__ = (
        Index('ix_evaluations_content', 'content_type', 'content_id', 'created_at'),
        Index('ix_evaluations_passed', 'passed', 'created_at'),
        Index('ix_evaluations_score', 'overall_score', 'created_at'),
    )

    def __repr__(self):
        return f"<EvaluationRun {self.id}: {self.content_type} score={self.overall_score:.2f}>"


class EvaluationIssue(Base):
    """
    Specific issues found during evaluation runs.

    Tracks hallucinations, poor advice, actionability problems, and other
    quality issues to enable targeted improvements and monitoring.
    """
    __tablename__ = "evaluation_issues"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Linked evaluation run
    evaluation_run_id = Column(UUID(as_uuid=True), ForeignKey("evaluation_runs.id", ondelete="CASCADE"), nullable=False, index=True)

    # Issue details
    issue_type = Column(String(50), nullable=False, index=True)  # hallucination, poor_advice, low_actionability, coherence_error
    severity = Column(String(20), nullable=False)  # critical, major, minor
    description = Column(Text, nullable=False)  # Human-readable description of the issue

    # Traceability
    affected_signal_ids = Column(ARRAY(UUID(as_uuid=True)), nullable=True)  # Signals involved in the issue
    affected_entities = Column(ARRAY(String), nullable=True)  # Entities involved

    # Additional context
    details = Column(JSON, nullable=True)  # Structured details for programmatic analysis

    # Metadata
    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)

    # Relationships
    evaluation_run = relationship("EvaluationRun", back_populates="issues")

    # Indexes for monitoring queries
    __table_args__ = (
        Index('ix_evaluation_issues_type', 'issue_type', 'severity', 'created_at'),
    )

    def __repr__(self):
        return f"<EvaluationIssue {self.id}: {self.issue_type} ({self.severity})>"
